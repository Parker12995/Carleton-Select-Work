---
title: "NIMBLE code for LGCP"
---

```{r}
library(nimble)
library(ggplot2)
library(fields)  # for rdist
library(glue)
library(dplyr)
```

```{r}
expcov <- nimbleFunction(run = function(dists = double(2), phi = double(0), sigma = double(0)) {
    returnType(double(2))
    n <- dim(dists)[1]
    m <- dim(dists)[2]
    result <- matrix(nrow = n, ncol = m, init = FALSE)
    sigma2 <- sigma*sigma
    for(i in 1:n){
      for(j in 1:m){
        result[i, j] <- sigma2*exp(-dists[i,j]/phi)
      }
    }
    return(result)
})
```

```{r}
getwd()
```


```{r}
######################load data###########################################################################
#bind in another script sim_points and the overlayed data below
sim_points <- read.csv("../../data/working/integration_points/494points_coord.csv")
over_sim_points_census <- read.csv("../../data/working/over_sim_points_census.csv")
over_uof_census <- read.csv("../../data/working/overlay_pointdatasets_censusdata/over_uof_census.csv")
minn_tracts.sf <- read.csv("../../data/working/minn_tracts_sf.csv")
knots <- read.csv("../../src/zhihan/lgcp_likelihood_inputs/knots.csv")

# knots <- head(knots, 10)
over_uof_census <- sample_n(over_uof_census, 100)
knots <- sample_n(knots, 2)

over_uof_census$perc_white <- over_uof_census$total_white/over_uof_census$total_pop
over_uof_census$perc_poverty <- over_uof_census$below_pov_level/over_uof_census$total_pop

over_sim_points_census$perc_white <- over_sim_points_census$total_white/over_sim_points_census$total_pop
over_sim_points_census$perc_poverty <- over_sim_points_census$below_pov_level/over_sim_points_census$total_pop

n_uof = nrow(over_uof_census)
n_sim = nrow(sim_points)
n_knots <- nrow(knots)

sim_covs <- as.matrix(over_sim_points_census[,c("perc_white", "perc_poverty")])
covs <- as.matrix(over_uof_census[,c("perc_white", "perc_poverty")])
XB <- vector(length=n_uof)
XB_int <- vector(length=n_sim)

# distance matrices
knots_dists <- rdist(knots, knots)
observed_pts_vs_knots_dists <- rdist(over_uof_census[,1:2], knots)
integration_pts_vs_knots_dists <- rdist(sim_points, knots)
```

```{r}
code <- nimbleCode({
  
  beta0 ~ dnorm(0, sd = 100)
  beta1 ~ dnorm(0, sd = 100)
  beta2 ~ dnorm(0, sd = 100)
  sigma ~ dinvgamma(0.1, 0.1)
  
  XB[1:n_uof] <- beta0 + beta1*covs[,1] + beta2*covs[,2]
  XB_int[1:n_sim] <- beta0 + beta1*sim_covs[,1] + beta2*sim_covs[,2]
  
  knots_cov[1:n_knots, 1:n_knots] <- expcov(knots_dists[1:n_knots, 1:n_knots], 0.1, sigma)
  observed_pts_vs_knots_cov[1:n_uof, 1:n_knots] <- expcov(observed_pts_vs_knots_dists[1:n_uof, 1:n_knots], 0.1, sigma)
  integration_pts_vs_knots_cov[1:n_sim, 1:n_knots] <- expcov(integration_pts_vs_knots_dists[1:n_sim, 1:n_knots], 0.1, sigma)
  
  gp_on_knots[1:n_knots] ~ dmnorm(knots_mean[1:n_knots], cov=knots_cov[1:n_knots, 1:n_knots])
  gp_on_observed_pts[1:n_uof] <- observed_pts_vs_knots_cov[1:n_uof, 1:n_knots] %*% inverse(knots_cov[1:n_knots, 1:n_knots]) %*% gp_on_knots[1:n_knots]
  gp_on_integration_pts[1:n_sim] <- integration_pts_vs_knots_cov[1:n_sim, 1:n_knots] %*% inverse(knots_cov[1:n_knots, 1:n_knots]) %*% gp_on_knots[1:n_knots]
  
  int <- (area / n_sim) * sum(exp(XB_int[1:n_sim] + gp_on_integration_pts[1:n_sim]))

  })
```

```{r}
Rmodel <- nimbleModel(
  code, 
  data = list(),
  inits = list(
    beta0 = 0,
    beta1 = 0,
    beta2 = 0,
    sigma = 1, 
    gp_on_knots = numeric(n_knots),
    gp_on_observed_pts = numeric(n_uof),
    gp_on_integration_pts = numeric(n_sim)
  ),
  constants = list(
    sim_covs = sim_covs, 
    covs = covs, 
    area = sum(minn_tracts.sf$tract_area),
    n_uof = n_uof, n_sim = n_sim,
    knots_mean = numeric(n_knots),
    knots_dists = knots_dists, observed_pts_vs_knots_dists = observed_pts_vs_knots_dists,
    integration_pts_vs_knots_dists = integration_pts_vs_knots_dists,
    n_knots = n_knots
  )
)
```

```{r}
Rmodel$initializeInfo()
```

```{r}
# Rmodel <- compileNimble(Rmodel)
```

```{r}
llFun <- nimbleFunction(
  setup = function(model) { },
  run = function() {
    ll <- sum(model$XB + model$gp_on_observed_pts) - model$int
    returnType(double())
    return(ll[1])
  }
)

RllFun <- llFun(Rmodel)

mcmcConf <- configureMCMC(Rmodel, nodes = NULL, monitors = c("beta0", "beta1", "beta2", "sigma", "gp_on_knots"))
# this ensures that gp_on_knots is monitored alongside of other nodes, but also makes sure that no default samplers are assigned

# adding custom samplers

mcmcConf$addSampler(target = "beta0", type = "RW_llFunction",
                    control = list(llFunction = RllFun, includesTarget = FALSE))

mcmcConf$addSampler(target = "beta1", type = "RW_llFunction",
                    control = list(llFunction = RllFun, includesTarget = FALSE))

mcmcConf$addSampler(target = "beta2", type = "RW_llFunction",
                    control = list(llFunction = RllFun, includesTarget = FALSE))

mcmcConf$addSampler(target = "sigma", type = "RW_llFunction",
                    control = list(llFunction = RllFun, includesTarget = FALSE))

mcmcConf$addSampler(target = "gp_on_knots", type = "RW_llFunction_block",
                    control = list(llFunction = RllFun, includesTarget = FALSE))

mcmcConf$printSamplers() 

Rmcmc <- buildMCMC(mcmcConf)
```

```{r}
mcmcConf$getUnsampledNodes()
```

```{r}
samples <- runMCMC(Rmcmc, 20000)
```

```{r}
samples
```

```{r}
colMeans(samples, )
```

```{r}
n_samples <- nrow(samples)

ggplot() + 
  geom_line(aes(x=1:n_samples, y=samples[, 1]), color="red") + 
  geom_line(aes(x=1:n_samples, y=samples[, 2]), color="green") + 
  geom_line(aes(x=1:n_samples, y=samples[, 3]), color="blue") +
  xlab("Number of samples") + 
  ylab("Value")

ggplot() + 
  geom_line(aes(x=1:n_samples, y=samples[, 4]), color="black") +
  geom_line(aes(x=1:n_samples, y=samples[, 5]), color="gray") +
  xlab("Number of samples") + 
  ylab("Value")

ggplot() + geom_line(aes(x=1:n_samples, y=samples[, ncol(samples)]))
```
