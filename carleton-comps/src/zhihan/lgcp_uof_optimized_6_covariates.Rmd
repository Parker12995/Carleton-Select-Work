---
title: "NIMBLE code for LGCP"
---

Run up to line 278 to save the samples; samples were saved in a Google Drive folder, not in R. Samples then loaded into src/zhihan/lgcp_log_intensity_surface.Rmd to create the intensity plots.

```{r}
set.seed(42)
```

```{r}
library(nimble)
library(ggplot2)
library(fields)  # for rdist
library(glue)
library(dplyr)
library(sf)
library(sp)
library(spatstat)
library(reshape2)
library(raster)  # for the count plot in the very end
library(coda)
library(invgamma)
library(ggmap)
library(tictoc)
library(bayesplot)
library(tidyverse)
```

```{r}
expcov <- nimbleFunction(run = function(dists = double(2), phi = double(0), sigma = double(0)) {
    returnType(double(2))
    sigma2 <- sigma*sigma
    result <- sigma2*exp(-dists/phi)
    return(result)
})
```

```{r}
getwd()
```

```{r}
#obs_data <- read.csv("../../data/working/ward_9_blockgroups/use_of_force/obs_points_with_bg_level_cov.csv")
#obs_data <- read.csv("../../data/working/ward_8_blockgroups/use_of_force/obs_points_with_bg_level_cov2.csv")
# obs_data <- read.csv("../../data/working/ward_9_blockgroups/use_of_force/obs_points_with_bg_level_cov.csv") %>% filter(Problem == "Suspicious Person")
# obs_data <- read.csv("../../data/working/ward_9_blockgroups/use_of_force/obs_points_with_bg_level_cov.csv") %>% filter(Problem != "Suspicious Person")
# obs_data <- read.csv("../../data/working/ward_9_blockgroups/use_of_force/obs_points_with_bg_level_cov.csv") %>% filter(PrimaryOffense == "OBSTRU")
# obs_data <- read.csv("../../data/working/ward_9_blockgroups/use_of_force/obs_points_with_bg_level_cov.csv") %>% filter(PrimaryOffense != "OBSTRU")
# obs_data <- read.csv("../../data/working/ward_9_blockgroups/use_of_force/obs_points_with_bg_level_cov.csv") %>% filter(Is911Call == "Yes")
# obs_data <- read.csv("../../data/working/ward_9_blockgroups/use_of_force/obs_points_with_bg_level_cov.csv") %>% filter(Is911Call == "No")
#obs_data <- read.csv("../../data/working/ward_9_blockgroups/use_of_force/obs_points_with_bg_level_cov.csv") %>% filter(ResponseDate < '2020/01/01' | str_detect(ResponseDate, "2020/01") | str_detect(ResponseDate, "2020/02") | str_detect(ResponseDate, "2020/03") | str_detect(ResponseDate, "2020/04") | str_detect(ResponseDate, "2020/05/0") | str_detect(ResponseDate, "2020/05/1"))
obs_data <- read.csv("../../data/working/ward_9_blockgroups/use_of_force/obs_points_with_bg_level_cov.csv") %>% filter(str_detect(ResponseDate, "2020/05/2") | str_detect(ResponseDate, "2020/05/3") | str_detect(ResponseDate, "2020/06") | str_detect(ResponseDate, "2020/07") | str_detect(ResponseDate, "2020/08") | str_detect(ResponseDate, "2020/09") | str_detect(ResponseDate, "2020/10") | str_detect(ResponseDate, "2020/11") | str_detect(ResponseDate, "2020/12"))
#obs_data <- read.csv("../../data/working/ward_9_blockgroups/use_of_force/obs_points_with_bg_level_cov.csv") %>% filter(ResponseDate > '2021-01-01')


obs_pts <- obs_data[, c("X", "Y")]

set.seed(3)
jitter_lat <- runif(n = nrow(obs_pts), 0.0001, 0.0005) #only goes to fifth decimal point
jitter_lon <- runif(n = nrow(obs_pts), 0.0001, 0.0005) #only goes to fifth decimal point

obs_pts$Y <- obs_pts$Y + jitter_lat
obs_pts$X <- obs_pts$X + jitter_lon

obs_cov <- obs_data[, c("total_pop", "med_hh_income", "perc_female", "herfendahl", "perc_unemployed", "perc_foodstamp")]
# obs_cov <- obs_data[, c("total_pop", "med_hh_income")]

obs_cov$total_pop = obs_cov$total_pop / 2193
obs_cov$med_hh_income = obs_cov$med_hh_income / 110208
#obs_cov$total_pop = obs_cov$total_pop / 1837
#obs_cov$med_hh_income = obs_cov$med_hh_income / 130563
```

```{r}
#int_data <- read.csv("../../data/working/ward_9_blockgroups/over_simpoints_cov_10000int_points.csv")
int_data <- read.csv("../../data/working/ward_9_blockgroups/over_simpoints_cov_20000int_points.csv")
#int_data <- read.csv("../../data/working/ward_8_blockgroups/over_simpoints_cov_10000int_points2.csv")

int_pts <- int_data[, c("x", "y")]

int_cov <- int_data[, c("total_pop", "med_hh_income", "perc_female", "herfendahl", "perc_unemployed", "perc_foodstamp")]
# int_cov <- int_data[, c("total_pop", "med_hh_income")]

int_cov$total_pop = int_cov$total_pop / 2193
int_cov$med_hh_income = int_cov$med_hh_income / 110208
#int_cov$total_pop = int_cov$total_pop / 1837
#int_cov$med_hh_income = int_cov$med_hh_income / 130563
```

```{r}
knots <- read.csv("../../data/working/ward_9_blockgroups/71_knots.csv")
#knots <- read.csv("../../data/working/ward_8_blockgroups/90_knots.csv")
```

```{r}
plot(int_pts, col="blue")
points(obs_pts, col="red")
points(knots, col="black")
```

```{r}
# (-93.23 - (-93.27)) * (44.955 - 44.935)
```

```{r}
n_uof = nrow(obs_pts)
n_sim = nrow(int_pts)
n_knots <- nrow(knots)

covs <- as.matrix(obs_pts)
sim_covs <- as.matrix(int_pts)  # in this case, the locations themselves are the covariates

# distance matrices
knots_dists <- rdist(knots, knots)
observed_pts_vs_knots_dists <- rdist(obs_pts, knots)
integration_pts_vs_knots_dists <- rdist(int_pts, knots)

# fix phi
dist_95 <- as.numeric(quantile(knots_dists, probs = c(0.95)))
dist_05 <- as.numeric(quantile(knots_dists, probs = c(0.05)))
#deciding range 
upper_unif <- -dist_95/log(0.05)
lower_unif <- -dist_05/log(0.95)
#deciding fixed value for phi
fix_phi <- (upper_unif+lower_unif)/2
fix_phi

knots_cov = expcov(knots_dists, phi=fix_phi, sigma=1)
observed_pts_vs_knots_cov = expcov(observed_pts_vs_knots_dists, phi=fix_phi, sigma=1)
integration_pts_vs_knots_cov = expcov(integration_pts_vs_knots_dists, phi=fix_phi, sigma=1)
```

```{r}
hist(knots_cov)
```

```{r}
load("../../data/working/ward_9_blockgroups/Ward9_Blocks.Rdata")
ward9_blocks.sf <- st_as_sf(ward9_blocks)
#load("../../data/working/ward_8_blockgroups/Ward8_Blocks.Rdata")
#ward8_blocks.sf <- st_as_sf(ward8_blocks)

# for (i in 1:nrow(ward9_blocks.sf)) {
#   ward9_blocks.sf[i, 48] <- area(st_transform(st_union(ward9_blocks.sf[i, ]),crs = 6345))
# }
```

```{r}
length(ward9_blocks.sf$GEOID)
#length(ward8_blocks.sf$GEOID)
```

```{r}
# colnames(ward9_blocks.sf)
```


```{r}
# asCol is probably not required; just for sanity check

code <- nimbleCode({
  
  # random variables
  
  beta0 ~ dnorm(0, sd = 100)
  beta1 ~ dnorm(0, sd = 100)
  beta2 ~ dnorm(0, sd = 100)
  beta3 ~ dnorm(0, sd = 100)
  beta4 ~ dnorm(0, sd = 100)
  beta5 ~ dnorm(0, sd = 100)
  beta6 ~ dnorm(0, sd = 100)
  sigma ~ dinvgamma(1, 0.7)
  gp_on_knots_raw[1:n_knots] ~ dmnorm(mean=knots_mean[1:n_knots], cov=knots_cov[1:n_knots, 1:n_knots])
  
  # deterministic computations
  
  # XB[1:n_uof] <- beta0 + beta1*covs[1:n_uof,1] + beta2*covs[1:n_uof,2]
  # XB_int[1:n_sim] <- beta0 + beta1*sim_covs[1:n_sim,1] + beta2*sim_covs[1:n_sim,2]
  
  XB[1:n_uof] <- beta0 + beta1*covs[1:n_uof,1] + beta2*covs[1:n_uof,2] + beta3*covs[1:n_uof,3] + beta4*covs[1:n_uof,4] + beta5*covs[1:n_uof,5] + beta6*covs[1:n_uof,6]
  XB_int[1:n_sim] <- beta0 + beta1*sim_covs[1:n_sim,1] + beta2*sim_covs[1:n_sim,2] + beta3*sim_covs[1:n_sim,3] + beta4*sim_covs[1:n_sim,4] + beta5*sim_covs[1:n_sim,5] + beta6*sim_covs[1:n_sim,6]

  gp_on_knots[1:n_knots] <- gp_on_knots_raw[1:n_knots] * sigma
  gp_on_observed_pts[1:n_uof] <- matrix1[1:n_uof, 1:n_knots] %*% asCol(gp_on_knots[1:n_knots])
  gp_on_integration_pts[1:n_sim] <- matrix2[1:n_sim, 1:n_knots] %*% asCol(gp_on_knots[1:n_knots])
  
  # log-likelihood (I put it here instead of in llFun so that NIMBLE can monitor it)
  
  integ <- area * mean(exp(asCol(XB_int[1:n_sim]) + asCol(gp_on_integration_pts[1:n_sim])))
  other_part <- sum(asCol(XB[1:n_uof]) + asCol(gp_on_observed_pts[1:n_uof]))
  ll <- other_part - integ

})
```

```{r}
Rmodel <- nimbleModel(
  code, 
  data = list(),
  inits = list(
    beta0 = 0,
    beta1 = 0,
    beta2 = 0,
    beta3 = 0,
    beta4 = 0,
    beta5 = 0,
    beta6 = 0,
    sigma = 1,
    gp_on_knots_raw = numeric(n_knots)
  ),
  constants = list(
    sim_covs = int_cov, 
    covs = obs_cov, 
    area = ward9_blocks.sf$SHAPE_Area[1],
    #area = ward8_blocks.sf$SHAPE_Area[1],
    n_uof = n_uof,
    n_sim = n_sim,
    knots_mean = numeric(n_knots),
    knots_cov = knots_cov, 
    matrix1 = observed_pts_vs_knots_cov %*% solve(knots_cov),
    matrix2 = integration_pts_vs_knots_cov %*% solve(knots_cov),
    n_knots = n_knots
  )
)
```

```{r}
Rmodel$initializeInfo()
```

```{r}
llFun <- nimbleFunction(
  setup = function(model) { },
  run = function() {
    returnType(double())
    return(model$ll[1])
  }
)

RllFun <- llFun(Rmodel)

mcmcConf <- configureMCMC(
  Rmodel, 
  nodes=NULL, 
  monitors = c("beta0", "beta1", "beta2", "beta3", "beta4", "beta5", "beta6", "gp_on_knots_raw", "sigma", "ll")
)

mcmcConf$addSampler(
  target = c("beta0", "beta1", "beta2", "beta3", "beta4", "beta5", "beta6", "gp_on_knots_raw", "sigma"),
  type = "RW_llFunction_block",
  control = list(llFunction = RllFun, includesTarget = F)
)

mcmcConf$printSamplers() 

Rmcmc <- buildMCMC(mcmcConf)

comp_model <- compileNimble(Rmodel)
comp_MCMC <- compileNimble(Rmcmc)
```

```{r}
mcmcConf$getUnsampledNodes()
```

```{r}
tic()
comp_MCMC$run(niter = as.integer(3e6))
toc()
```

```{r}
samples <- as.matrix(comp_MCMC$mvSamples) %>% as.data.frame()
```

```{r}
save(samples, file="lgcp_uof_6cov_3million_during_GF.Rda")
```


```{r}
load("lgcp_uof_6cov_1million_samples.Rda")
```

```{r}
# make plotting faster
every <- 1000
samples_for_plotting <- samples[seq(1, nrow(samples), every), ]
```

```{r}
library(zoo)

n_samples <- nrow(samples_for_plotting)

ggplot() + 
  geom_line(aes(
    x=1:n_samples * every, 
    y=samples_for_plotting[, ncol(samples_for_plotting) - 1]
  ), color="black") + 
  ylab("Log-likelihood on a log scale") + 
  xlab("Iteration")

ggplot() + 
  geom_abline(intercept=0, slope=0) +
  geom_line(aes(x=1:n_samples * every, y=samples_for_plotting[, 1], color="beta0")) + 
  geom_line(aes(x=1:n_samples * every, y=samples_for_plotting[, 2], color="beta1 (Total Population)")) + 
  geom_line(aes(x=1:n_samples * every, y=samples_for_plotting[, 3], color="beta2 (Median Household Income)")) +
  geom_line(aes(x=1:n_samples * every, y=samples_for_plotting[, 4], color="beta3 (Perc. Female)")) +
  geom_line(aes(x=1:n_samples * every, y=samples_for_plotting[, 5], color="beta4 (Herfendahl Index)")) +
  geom_line(aes(x=1:n_samples * every, y=samples_for_plotting[, 6], color="beta5 (Perc. Unemployed)")) +
  geom_line(aes(x=1:n_samples * every, y=samples_for_plotting[, 7], color="beta6 (Perc. Foodstamp)")) +
  scale_color_manual(
    name = "Regression\nCoefficients", 
    values = c(
      "beta0" = "black", 
      "beta1 (Total Population)" = "red", 
      "beta2 (Median Household Income)" = "orange", 
      "beta3 (Perc. Female)" = "green",
      "beta4 (Herfendahl Index)" = "blue",
      "beta5 (Perc. Unemployed)" = "purple",
      "beta6 (Perc. Foodstamp)" = "pink"
    )
  ) + 
  xlab("Iteration") + 
  ylab("Value")

melted_samples <- melt(cbind(1:n_samples, samples_for_plotting[, 8:9]), id.vars="1:n_samples")
colnames(melted_samples)[1] <- "index"

ggplot() +
  geom_line(data=melted_samples, aes(x=index * every, y=value, color=variable)) +
  xlab("Iteration") +
  ylab("GP values (on a 2 knots)") +
  theme(legend.position="none")

ggplot() + 
  geom_line(aes(x=1:n_samples * every, y=samples_for_plotting[, ncol(samples)])) + 
  geom_abline(intercept=1, slope=0, linetype="dashed", color="black") +
  xlab("Iteration") +
  ylab("Sigma")
```

```{r}
samples_no_burnin <- samples[1000000:2000000, ]
```

```{r}
colMeans(samples_no_burnin[1:7])
```

```{r}
effectiveSize(samples_no_burnin[1:7])
```

```{r}
effectiveSize(samples_no_burnin[ncol(samples_no_burnin)])
```

```{r}
mcmc_intervals(samples_no_burnin[2:7], prob_outer=0.95, prob=0.5, outer_size=5, inner_size=5, point_size=2) + 
  scale_y_discrete(
    labels = c(
     # "beta0" = "beta0 (intercept)",
      "beta1" = "beta1 (normalized total population)",
      "beta2" = "beta2 (normalized median household income)",
      "beta3" = "beta3 (percent female)",
      "beta4" = "beta4 (Herfendahl index)",
      "beta5" = "beta5 (percent unemployed)",
      "beta6" = "beta6 (percent foodstamp)"
    )
  )
```

```{r}
xs = seq(0, 20, length.out=100)
ggplot() + 
  geom_density(data=NULL, aes(x=samples_no_burnin[, ncol(samples_no_burnin)], color="Posterior")) + 
  geom_line(data=NULL, aes(x=xs, y=dinvgamma(xs, 1, 0.7), color="Prior")) + 
  scale_color_manual(name = "Distributions\nover Sigma", values = c("Prior" = "black", "Posterior" = "red")) + 
  ylab("Density") + 
  xlab("Value")
```

# Surface

```{r}
coordinates(knots) <- ~lon+lat
proj4string(knots) <- proj4string(ward9_blocks)
over_knots_bg_in_ward9 <- over(knots, ward9_blocks)
#proj4string(knots) <- proj4string(ward8_blocks)
#over_knots_bg_in_ward8 <- over(knots, ward8_blocks)

covs_knots <- over_knots_bg_in_ward9[, c("total_pop", "med_hh_income", "perc_female", "herfendahl", "perc_unemployed", "perc_foodstamp")]
#covs_knots <- over_knots_bg_in_ward8[, c("total_pop", "med_hh_income", "perc_female", "herfendahl", "perc_unemployed", "perc_foodstamp")]
covs_knots$total_pop = covs_knots$total_pop / 2193
covs_knots$med_hh_income = covs_knots$med_hh_income / 110208
#covs_knots$total_pop = covs_knots$total_pop / 1837
#covs_knots$med_hh_income = covs_knots$med_hh_income / 130563
covs_knots <- cbind(rep(1, nrow(covs_knots)), covs_knots)
```

```{r}
beta_means <- colMeans(samples_no_burnin[,1:7])
gp_means <- colMeans(samples_no_burnin[,8:(ncol(samples)-2)] * samples_no_burnin[,ncol(samples)-1])

log_intensities <- as.matrix(covs_knots) %*% as.matrix(beta_means) + gp_means
log_intensities_no_gp <- as.matrix(covs_knots) %*% as.matrix(beta_means)
log_intensities_exp <- exp(log_intensities)
```


```{r}
ggplot() +
  geom_density2d_filled(data=obs_pts, aes(x=X, y=Y)) +
  coord_fixed()
```

```{r}
ggplot() +
  geom_point(data=as.data.frame(knots), aes(x = lon, y = lat, color = log_intensities_no_gp), size=5, shape=15) +
  #geom_point(data=obs_pts, aes(x=x, y=y), size=2, shape=1, color="black") +
  scale_color_viridis() +
  coord_fixed()
```

```{r}
ggplot() + 
  geom_point(data=as.data.frame(knots), aes(x = lon, y = lat, color = log_intensities), size=5, shape=15) + 
  scale_color_viridis() + 
  coord_fixed()
```

```{r}
r <- raster(xmn=-10, ymn=-10, xmx=10, ymx=10, res=2)
counts <- as.matrix(rasterize(obs_pts, r, fun='count'))
counts <- counts[nrow(counts):1, ]
counts <- c(t(counts))
area <- 400 / 100
intensities <- counts / area
log_intensities_truth <- log(intensities)

# c(t()) means as vector by row
ggplot() + 
  geom_point(data=knots, aes(x = x, y = y, color = log_intensities_truth), size=15, shape=15) +
  scale_color_viridis() + 
  coord_fixed()
```

```{r}
ggplot(data=NULL, aes(x=log_intensities_no_gp, y=log_intensities_truth)) + 
  geom_point() + 
  geom_smooth(method='lm', formula=y~x, se=F)
```

```{r}
ggplot(data=NULL, aes(x=log_intensities, y=log_intensities_truth)) + 
  geom_point() + 
  geom_smooth(method='lm', formula=y~x, se=F) + 
  coord_fixed()
```

# Log-intensity surface over integration points

```{r}
ward9_map <- get_map(c(left = -93.28, bottom = 44.93, 
                         right = -93.225, top = 44.965), source = "stamen")
#ward8_map <- ggmap(get_map(c(left = -93.294, bottom = 44.908, 
#                            right = -93.244, top = 44.9521), source = "stamen"))
```

```{r}
# matrix(c(1, 1, 1, 1, 1, 1, 1, 1, 1), nrow=3) * c(1, 2, 3)
```

```{r}
covs_int <- int_cov
covs_int <- cbind(rep(1, nrow(covs_int)), covs_int)

beta_means <- colMeans(samples_no_burnin[,1:7])
gp_means <- colMeans(samples_no_burnin[,8:(ncol(samples)-2)] * samples_no_burnin[,ncol(samples)])

# here are everything that can be plotted
log_intensities <- as.matrix(covs_int) %*% as.matrix(beta_means) + integration_pts_vs_knots_cov %*% solve(knots_cov) %*% gp_means
log_intensities_no_gp <- as.matrix(covs_int) %*% as.matrix(beta_means)
gp <- integration_pts_vs_knots_cov %*% solve(knots_cov) %*% gp_means
log_intensities_exp <- exp(log_intensities)

ggmap(ward9_map) +
  geom_point(data=int_pts, aes(x = x, y = y, color = log_intensities), size=2.5, shape=15) +
  scale_color_viridis(name='Log intensity') +
  geom_polygon(data=ward9_blocks, aes(x = long, y = lat, group = group), fill=NA, color="black") +
  coord_fixed() +
  geom_point(data=obs_pts, aes(x=X, y=Y), alpha=0.1, shape=1) +
  xlab("Longitude") +
  ylab("Latitude") +
  ggtitle("Log intensity surface of all use-of-force incidents (over Ward 9 Minneapolis)") +
  theme(axis.title = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank())

# ggmap(ward8_map) + 
#   geom_point(data=int_pts, aes(x = x, y = y, color = log_intensities), size=2.5, shape=15) +
#   scale_color_viridis(name='Log intensity') + 
#   geom_polygon(data=ward8_blocks, aes(x = long, y = lat, group = group), fill=NA, color="black") + 
#   coord_fixed() +
#   geom_point(data=obs_pts, aes(x=X, y=Y), alpha=0.1, shape=1) + 
#   xlab("Longitude") + 
#   ylab("Latitude") + 
#   ggtitle("Log intensity surface of all use-of-force incidents (over Ward 9 Minneapolis)") + 
#   theme(axis.title = element_blank(),
#         axis.text = element_blank(),
#         axis.ticks = element_blank())
```


