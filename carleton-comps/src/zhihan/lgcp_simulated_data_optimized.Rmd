---
title: "NIMBLE code for LGCP"
---

```{r}
set.seed(42)
```

```{r}
library(nimble)
library(ggplot2)
library(fields)  # for rdist
library(glue)
library(dplyr)
library(sf)
library(sp)
library(spatstat)
library(reshape2)
library(raster)  # for the count plot in the very end
library(coda)
library(invgamma)
```

```{r}
expcov <- nimbleFunction(run = function(dists = double(2), phi = double(0), sigma = double(0)) {
    returnType(double(2))
    sigma2 <- sigma*sigma
    result <- sigma2*exp(-dists/phi)
    return(result)
})
```

```{r}
# true parameters:
# beta0 = 1
# beta1 = 0.1
# beta2 = 0.1
# phi = 4
# sigma = 1
obs_pts <- read.csv("simulated_lgcp_1_0d1_0d1.csv")[, c(2, 3)]

knots_xs <- seq(from = -10, to = 10, length.out = 10)
knots_ys <- seq(from = -10, to = 10, length.out = 10)
knots <- expand.grid(knots_xs, knots_ys)
colnames(knots) <- c("x", "y")

set.seed(42)
int_xs <- runif(10000, min=-10, max=10)
int_ys <- runif(10000, min=-10, max=10)
int_pts <- data.frame(cbind(int_xs, int_ys))
colnames(int_pts) <- c("x", "y")
```

```{r}
dim(obs_pts)
```


```{r}
plot(int_pts, col="blue", asp = 1)
points(obs_pts, col="red")
points(knots, col="black")
```

```{r}
n_uof = nrow(obs_pts)
n_sim = nrow(int_pts)
n_knots <- nrow(knots)

covs <- as.matrix(obs_pts)
sim_covs <- as.matrix(int_pts)  # in this case, the locations themselves are the covariates

# distance matrices
knots_dists <- rdist(knots, knots)
observed_pts_vs_knots_dists <- rdist(obs_pts, knots)
integration_pts_vs_knots_dists <- rdist(int_pts, knots)

# fix phi
dist_95 <- as.numeric(quantile(knots_dists, probs = c(0.95)))
dist_05 <- as.numeric(quantile(knots_dists, probs = c(0.05)))
#deciding range 
upper_unif <- -dist_95/log(0.05)
lower_unif <- -dist_05/log(0.95)
#deciding fixed value for phi
fix_phi <- (upper_unif+lower_unif)/2
fix_phi

knots_cov = expcov(knots_dists, fix_phi, 1)
observed_pts_vs_knots_cov = expcov(observed_pts_vs_knots_dists, fix_phi, 1)
integration_pts_vs_knots_cov = expcov(integration_pts_vs_knots_dists, fix_phi, 1)
```

```{r}
hist(knots_cov)
```


```{r}
# asCol is probably not required; just for sanity check

code <- nimbleCode({
  
  # random variables
  
  beta0 ~ dnorm(0, sd = 100)
  beta1 ~ dnorm(0, sd = 100)
  beta2 ~ dnorm(0, sd = 100)
  sigma ~ dinvgamma(1, 1)
  gp_on_knots_raw[1:n_knots] ~ dmnorm(mean=knots_mean[1:n_knots], cov=knots_cov[1:n_knots, 1:n_knots])
  
  # deterministic computations
  
  XB[1:n_uof] <- beta0 + beta1*covs[1:n_uof,1] + beta2*covs[1:n_uof,2]
  XB_int[1:n_sim] <- beta0 + beta1*sim_covs[1:n_sim,1] + beta2*sim_covs[1:n_sim,2]

  gp_on_knots[1:n_knots] <- gp_on_knots_raw[1:n_knots] * sigma
  gp_on_observed_pts[1:n_uof] <- matrix1[1:n_uof, 1:n_knots] %*% asCol(gp_on_knots[1:n_knots])
  gp_on_integration_pts[1:n_sim] <- matrix2[1:n_sim, 1:n_knots] %*% asCol(gp_on_knots[1:n_knots])

  # these were used for debugging
  #integ_inside[1:n_sim] <- asCol(XB_int[1:n_sim]) + asCol(gp_on_integration_pts[1:n_sim])  
  #integ_inside_sum <- sum(integ_inside[1:n_sim]) / n_sim * n_uof
  
  # log-likelihood (I put it here instead of in llFun so that NIMBLE can monitor it)
  
  integ <- area * mean(exp(asCol(XB_int[1:n_sim]) + asCol(gp_on_integration_pts[1:n_sim])  ))
  other_part <- sum(asCol(XB[1:n_uof]) + asCol(gp_on_observed_pts[1:n_uof]))
  ll <- other_part - integ

})
```

```{r}
Rmodel <- nimbleModel(
  code, 
  data = list(),
  inits = list(
    beta0 = 0,
    beta1 = 0,
    beta2 = 0,
    sigma = 1,
    gp_on_knots_raw = numeric(n_knots)
  ),
  constants = list(
    sim_covs = sim_covs, 
    covs = covs, 
    area = 400,
    n_uof = n_uof,
    n_sim = n_sim,
    knots_mean = numeric(n_knots),
    knots_cov = knots_cov, 
    matrix1 = observed_pts_vs_knots_cov %*% solve(knots_cov),
    matrix2 = integration_pts_vs_knots_cov %*% solve(knots_cov),
    n_knots = n_knots
  )
)
```

```{r}
Rmodel$initializeInfo()
```

```{r}
llFun <- nimbleFunction(
  setup = function(model) { },
  run = function() {
    returnType(double())
    return(model$ll[1])
  }
)

RllFun <- llFun(Rmodel)

mcmcConf <- configureMCMC(
  Rmodel, 
  nodes=NULL, 
  monitors = c("beta0", "beta1", "beta2", "gp_on_knots_raw", "gp_on_knots", "sigma", "ll")
)

mcmcConf$addSampler(
  target = c("beta0", "beta1", "beta2", "gp_on_knots_raw", "sigma"),
  type = "RW_llFunction_block",
  control = list(llFunction = RllFun, includesTarget = F)
)

mcmcConf$printSamplers() 

Rmcmc <- buildMCMC(mcmcConf)

comp_model <- compileNimble(Rmodel)
comp_MCMC <- compileNimble(Rmcmc)
```

```{r}
mcmcConf$getUnsampledNodes()
```

```{r}
comp_MCMC$run(niter = as.integer(1e5))
```

```{r}
samples <- as.matrix(comp_MCMC$mvSamples) %>% as.data.frame()
```

```{r}
# save(samples, file="lgcp_simulated_1million_samples.Rda")
```

```{r}
# load("~/Downloads/lgcp_simulated_1million_samples.Rda")
```

```{r}
# make plotting faster
every <- 100
samples_for_plotting <- samples[seq(1, nrow(samples), every), ]
```

```{r}
# index of corresponding variables
# 1: beta0
# 2: beta1
# 3: beta2
# 4 ~ 4 + number of knots: gp_on_knots
# second last one: ll (log-likelihood)
# last one: sigma

n_samples <- nrow(samples_for_plotting)

ggplot() + 
  geom_line(aes(x=1:n_samples * every, y=samples_for_plotting[, ncol(samples_for_plotting) - 1]), color="black") +
  ylab("Log-likelihood") + 
  xlab("Iteration")

ggplot() + 
  geom_line(aes(x=1:n_samples * every, y=samples_for_plotting[, 1], color="beta0")) + 
  geom_abline(intercept=1, slope=0, linetype="dashed") +
  geom_line(aes(x=1:n_samples * every, y=samples_for_plotting[, 2], color="beta1")) + 
  geom_abline(intercept=0.1, slope=0, linetype="dashed", color="red") +
  geom_line(aes(x=1:n_samples * every, y=samples_for_plotting[, 3], color="beta2")) +
  geom_abline(intercept=-0.1, slope=0, linetype="dashed", color="blue") +
  scale_color_manual(name = "Regression\nCoef.", values = c("beta0" = "black", "beta1" = "red", "beta2" = "blue")) + 
  xlab("Iteration") + 
  ylab("Value")

melted_samples <- melt(cbind(1:n_samples, samples_for_plotting[, 4:5]), id.vars="1:n_samples")
colnames(melted_samples)[1] <- "index"

ggplot() +
  geom_line(data=melted_samples, aes(x=index * every, y=value, color=variable, alpha=0.1)) +
  xlab("Iteration") +
  ylab("GP values (on a 2 knots)") +
  theme(legend.position="none")

ggplot() + 
  geom_line(aes(x=1:n_samples * every, y=samples_for_plotting[, ncol(samples)])) + 
  geom_abline(intercept=1, slope=0, linetype="dashed", color="black") +
  xlab("Iteration") +
  ylab("Sigma")
```

```{r}
samples_no_burnin <- samples[50000:100000, ]
```

```{r}
colMeans(samples_no_burnin)
```

```{r}
xs = seq(0, 10, length.out=100)
ggplot() + 
  geom_density(data=NULL, aes(x=samples_no_burnin[, ncol(samples_no_burnin)], color="Posterior")) + 
  geom_line(data=NULL, aes(x=xs, y=dinvgamma(xs, 1, 1), color="Prior")) + 
  scale_color_manual(name = "Distributions\nover Sigma", values = c("Prior" = "black", "Posterior" = "red")) + 
  ylab("Density") + 
  xlab("Value")
```

```{r}
covs_knots <- knots
covs_knots <- cbind(rep(1, nrow(covs_knots)), covs_knots)

beta_means <- colMeans(samples_no_burnin[,1:3])
gp_means <- colMeans(samples_no_burnin[,4:(ncol(samples)-2-n_knots)])

log_intensities <- as.matrix(covs_knots) %*% as.matrix(beta_means) + gp_means
log_intensities_no_gp <- as.matrix(covs_knots) %*% as.matrix(beta_means)
log_intensities_exp <- exp(log_intensities)
```

```{r}
ggplot() +
  geom_density2d_filled(data=obs_pts, aes(x=x, y=y)) +
  coord_fixed()
```

```{r}
ggplot() +
  geom_point(data=as.data.frame(knots), aes(x = x, y = y, color = log_intensities_no_gp), size=18, shape=15) +
  #geom_point(data=obs_pts, aes(x=x, y=y), size=2, shape=1, color="black") +
  scale_color_viridis() +
  coord_fixed()
```

```{r}
ggplot() + 
  geom_point(data=knots, aes(x = x, y = y, color = log_intensities), size=14, shape=15) + 
  scale_color_viridis() + 
  coord_fixed()
```

```{r}
r <- raster(xmn=-10, ymn=-10, xmx=10, ymx=10, res=2)
counts <- as.matrix(rasterize(obs_pts, r, fun='count'))
counts <- counts[nrow(counts):1, ]
counts <- c(t(counts))
area <- 400 / 100
intensities <- counts / area
log_intensities_truth <- log(intensities)

# c(t()) means as vector by row
ggplot() + 
  geom_point(data=knots, aes(x = x, y = y, color = log_intensities_truth), size=15, shape=15) +
  scale_color_viridis() + 
  coord_fixed()
```

```{r}
ggplot(data=NULL, aes(x=log_intensities_truth, y=log_intensities_no_gp)) + 
  geom_point() + 
  geom_smooth(method='lm', formula=y~x, se=F)
```

```{r}
ggplot(data=NULL, aes(x=log_intensities_truth, y=log_intensities)) + 
  geom_point() + 
  geom_smooth(method='lm', formula=y~x, se=F)
```

```{r}
covs_int <- int_pts
covs_int <- cbind(rep(1, nrow(covs_int)), covs_int)

beta_means <- colMeans(samples_no_burnin[,1:3])
gp_means <- colMeans(samples_no_burnin[,4:(ncol(samples)-2-n_knots)])

log_intensities <- as.matrix(covs_int) %*% as.matrix(beta_means) + integration_pts_vs_knots_cov %*% solve(knots_cov) %*% gp_means

ggplot() + 
  geom_point(data=int_pts, aes(x = x, y = y, color = log_intensities), size=3) +
  scale_color_viridis() + 
  coord_fixed()
```


