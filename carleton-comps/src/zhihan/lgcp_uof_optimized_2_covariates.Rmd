---
title: "NIMBLE code for LGCP"
---

```{r}
set.seed(42)
```

```{r}
library(nimble)
library(ggplot2)
library(fields)  # for rdist
library(glue)
library(dplyr)
library(sf)
library(sp)
library(spatstat)
library(reshape2)
library(raster)  # for the count plot in the very end
library(coda)
library(invgamma)
library(ggmap)
```

```{r}
expcov <- nimbleFunction(run = function(dists = double(2), phi = double(0), sigma = double(0)) {
    returnType(double(2))
    sigma2 <- sigma*sigma
    result <- sigma2*exp(-dists/phi)
    return(result)
})
```

```{r}
getwd()
```

```{r}
obs_data <- read.csv("../../data/working/ward_9_blockgroups/use_of_force/obs_points_with_bg_level_cov.csv")
# obs_data <- obs_data[1:100, ]

obs_pts <- obs_data[, c("X", "Y")]

set.seed(3)
jitter_lat <- runif(n = nrow(obs_pts), 0.0001, 0.0005) #only goes to fifth decimal point
jitter_lon <- runif(n = nrow(obs_pts), 0.0001, 0.0005) #only goes to fifth decimal point

obs_pts$Y <- obs_pts$Y + jitter_lat
obs_pts$X <- obs_pts$X + jitter_lon

# obs_cov <- obs_data[, c("total_pop", "med_hh_income", "perc_female", "herfendahl", "perc_unemployed", "perc_foodstamp")]
obs_cov <- obs_data[, c("total_pop", "med_hh_income")]

obs_cov$total_pop = obs_cov$total_pop / 2193
obs_cov$med_hh_income = obs_cov$med_hh_income / 110208
```

```{r}
int_data <- read.csv("../../data/working/ward_9_blockgroups/over_simpoints_cov_10000int_points.csv")

int_pts <- int_data[, c("x", "y")]

# int_cov <- int_data[, c("total_pop", "med_hh_income", "perc_female", "herfendahl", "perc_unemployed", "perc_foodstamp")]
int_cov <- int_data[, c("total_pop", "med_hh_income")]

int_cov$total_pop = int_cov$total_pop / 2193
int_cov$med_hh_income = int_cov$med_hh_income / 110208
```

```{r}
knots <- read.csv("../../data/working/ward_9_blockgroups/71_knots.csv")
```

```{r}
plot(int_pts, col="blue")
points(obs_pts, col="red")
points(knots, col="black")
```

```{r}
# (-93.23 - (-93.27)) * (44.955 - 44.935)
```

```{r}
n_uof = nrow(obs_pts)
n_sim = nrow(int_pts)
n_knots <- nrow(knots)

covs <- as.matrix(obs_pts)
sim_covs <- as.matrix(int_pts)  # in this case, the locations themselves are the covariates

# distance matrices
knots_dists <- rdist(knots, knots)
observed_pts_vs_knots_dists <- rdist(obs_pts, knots)
integration_pts_vs_knots_dists <- rdist(int_pts, knots)

# fix phi
dist_95 <- as.numeric(quantile(knots_dists, probs = c(0.95)))
dist_05 <- as.numeric(quantile(knots_dists, probs = c(0.05)))
#deciding range 
upper_unif <- -dist_95/log(0.05)
lower_unif <- -dist_05/log(0.95)
#deciding fixed value for phi
fix_phi <- (upper_unif+lower_unif)/2
fix_phi

knots_cov = expcov(knots_dists, phi=fix_phi, sigma=1)
observed_pts_vs_knots_cov = expcov(observed_pts_vs_knots_dists, phi=fix_phi, sigma=1)
integration_pts_vs_knots_cov = expcov(integration_pts_vs_knots_dists, phi=fix_phi, sigma=1)
```

```{r}
hist(knots_cov)
```


```{r}
load("../../data/working/ward_9_blockgroups/Ward9_Blocks.Rdata")
ward9_blocks.sf <- st_as_sf(ward9_blocks)
# for (i in 1:nrow(ward9_blocks.sf)) {
#   ward9_blocks.sf[i, 48] <- area(st_transform(st_union(ward9_blocks.sf[i, ]),crs = 6345))
# }
```

```{r}
length(ward9_blocks.sf$GEOID)
```
```{r}
# colnames(ward9_blocks.sf)
```


```{r}
# asCol is probably not required; just for sanity check

code <- nimbleCode({
  
  # random variables
  
  beta0 ~ dnorm(0, sd = 100)
  beta1 ~ dnorm(0, sd = 100)
  beta2 ~ dnorm(0, sd = 100)
  # beta3 ~ dnorm(0, sd = 100)
  # beta4 ~ dnorm(0, sd = 100)
  # beta5 ~ dnorm(0, sd = 100)
  # beta6 ~ dnorm(0, sd = 100)
  sigma ~ dinvgamma(1, 0.7)
  gp_on_knots_raw[1:n_knots] ~ dmnorm(mean=knots_mean[1:n_knots], cov=knots_cov[1:n_knots, 1:n_knots])
  
  # deterministic computations
  
  XB[1:n_uof] <- beta0 + beta1*covs[1:n_uof,1] + beta2*covs[1:n_uof,2]
  XB_int[1:n_sim] <- beta0 + beta1*sim_covs[1:n_sim,1] + beta2*sim_covs[1:n_sim,2]
  
  # XB[1:n_uof] <- beta0 + beta1*covs[1:n_uof,1] + beta2*covs[1:n_uof,2] + beta3*covs[1:n_uof,3] + beta4*covs[1:n_uof,4] + beta5*covs[1:n_uof,5] + beta6*covs[1:n_uof,6]
  # XB_int[1:n_sim] <- beta0 + beta1*sim_covs[1:n_sim,1] + beta2*sim_covs[1:n_sim,2] + beta3*sim_covs[1:n_sim,3] + beta4*sim_covs[1:n_sim,4] + beta5*sim_covs[1:n_sim,5] + beta6*sim_covs[1:n_sim,6]

  gp_on_knots[1:n_knots] <- gp_on_knots_raw[1:n_knots] * sigma
  gp_on_observed_pts[1:n_uof] <- matrix1[1:n_uof, 1:n_knots] %*% asCol(gp_on_knots[1:n_knots])
  gp_on_integration_pts[1:n_sim] <- matrix2[1:n_sim, 1:n_knots] %*% asCol(gp_on_knots[1:n_knots])
  
  # log-likelihood (I put it here instead of in llFun so that NIMBLE can monitor it)
  
  integ <- area * mean(exp(asCol(XB_int[1:n_sim]) + asCol(gp_on_integration_pts[1:n_sim])  ))
  other_part <- sum(asCol(XB[1:n_uof]) + asCol(gp_on_observed_pts[1:n_uof]))
  ll <- other_part - integ

})
```

```{r}
Rmodel <- nimbleModel(
  code, 
  data = list(),
  inits = list(
    beta0 = 0,
    beta1 = 0,
    beta2 = 0,
    # beta3 = 0,
    # beta4 = 0,
    # beta5 = 0,
    # beta6 = 0,
    sigma = 1,
    gp_on_knots_raw = numeric(n_knots)
  ),
  constants = list(
    sim_covs = int_cov, 
    covs = obs_cov, 
    area = ward9_blocks.sf$SHAPE_Area[1],  # TODO
    n_uof = n_uof,
    n_sim = n_sim,
    knots_mean = numeric(n_knots),
    knots_cov = knots_cov, 
    matrix1 = observed_pts_vs_knots_cov %*% solve(knots_cov),
    matrix2 = integration_pts_vs_knots_cov %*% solve(knots_cov),
    n_knots = n_knots
  )
)
```

```{r}
Rmodel$initializeInfo()
```

```{r}
llFun <- nimbleFunction(
  setup = function(model) { },
  run = function() {
    returnType(double())
    return(model$ll[1])
  }
)

RllFun <- llFun(Rmodel)

mcmcConf <- configureMCMC(
  Rmodel, 
  nodes=NULL, 
  monitors = c("beta0", "beta1", "beta2", "gp_on_knots_raw", "gp_on_knots", "sigma", "ll")
)
# monitors = c("beta0", "beta1", "beta2", "beta3", "beta4", "beta5", "beta6", "gp_on_knots_raw", "gp_on_knots", "sigma", "ll")

mcmcConf$addSampler(
  target = c("beta0", "beta1", "beta2", "gp_on_knots_raw", "sigma"),
  type = "RW_llFunction_block",
  control = list(llFunction = RllFun, includesTarget = F)
)

# c("beta0", "beta1", "beta2", "beta3", "beta4", "beta5", "beta6", "gp_on_knots_raw", "sigma"),

mcmcConf$printSamplers() 

Rmcmc <- buildMCMC(mcmcConf)

comp_model <- compileNimble(Rmodel)
comp_MCMC <- compileNimble(Rmcmc)
```

```{r}
mcmcConf$getUnsampledNodes()
```

```{r}
comp_MCMC$run(niter = as.integer(1e6))
```

```{r}
samples <- as.matrix(comp_MCMC$mvSamples) %>% as.data.frame()
```

```{r}
save(samples, file="lgcp_uof_1million_samples.Rda")
```

```{r}
load("~/Downloads/lgcp_simulated_1million_samples.Rda")
```

```{r}
# make plotting faster
every <- 1000
samples_for_plotting <- samples[seq(1, nrow(samples), every), ]
```

```{r}
library(zoo)

n_samples <- nrow(samples_for_plotting)

ggplot() + 
  geom_line(aes(
    x=1:n_samples * every, 
    y=rollmean(log(samples_for_plotting[, ncol(samples_for_plotting) - 1]), k=20, na.pad=TRUE)
  ), color="black") + 
  ylab("Log-likelihood on a log scale") + 
  xlab("Iteration") + 
  ylim(10.7280, 10.73)

ggplot() + 
  geom_abline(intercept=0, slope=0) +
  geom_line(aes(x=1:n_samples * every, y=samples_for_plotting[, 1], color="beta0")) + 
  geom_line(aes(x=1:n_samples * every, y=samples_for_plotting[, 2], color="beta1 (total_pop)")) + 
  geom_line(aes(x=1:n_samples * every, y=samples_for_plotting[, 3], color="beta2 (med_hh_income)")) +
  # geom_line(aes(x=1:n_samples * every, y=samples_for_plotting[, 4], color="beta3 (perc_female)")) +
  # geom_line(aes(x=1:n_samples * every, y=samples_for_plotting[, 5], color="beta4 (herfendahl)")) +
  # geom_line(aes(x=1:n_samples * every, y=samples_for_plotting[, 6], color="beta5 (perc_unemployed)")) +
  # geom_line(aes(x=1:n_samples * every, y=samples_for_plotting[, 7], color="beta6 (perc_foodstamp)")) +
  scale_color_manual(
    name = "Regression\nCoef.", 
    values = c(
      "beta0" = "black", 
      "beta1 (total_pop)" = "red", 
      "beta2 (med_hh_income)" = "orange" # , 
      # "beta3 (perc_female)" = "green", 
      # "beta4 (herfendahl)" = "blue", 
      # "beta5 (perc_unemployed)" = "purple", 
      # "beta6 (perc_foodstamp)" = "pink"
    )
  ) + 
  xlab("Iteration") + 
  ylab("Value")

melted_samples <- melt(cbind(1:n_samples, samples_for_plotting[, 8:9]), id.vars="1:n_samples")
colnames(melted_samples)[1] <- "index"

ggplot() +
  geom_line(data=melted_samples, aes(x=index * every, y=value, color=variable)) +
  xlab("Iteration") +
  ylab("GP values (on a 2 knots)") +
  theme(legend.position="none")

ggplot() + 
  geom_line(aes(x=1:n_samples * every, y=samples_for_plotting[, ncol(samples)])) + 
  geom_abline(intercept=1, slope=0, linetype="dashed", color="black") +
  xlab("Iteration") +
  ylab("Sigma")
```

```{r}
samples_no_burnin <- samples[500000:1000000, ]
```

```{r}
xs = seq(0, 20, length.out=100)
ggplot() + 
  geom_density(data=NULL, aes(x=samples_no_burnin[, ncol(samples_no_burnin)], color="Posterior")) + 
  geom_line(data=NULL, aes(x=xs, y=dinvgamma(xs, 1, 1), color="Prior")) + 
  scale_color_manual(name = "Distributions\nover Sigma", values = c("Prior" = "black", "Posterior" = "red")) + 
  ylab("Density") + 
  xlab("Value")
```

# Surface

```{r}
coordinates(knots) <- ~lon+lat
proj4string(knots) <- proj4string(ward9_blocks)
over_knots_bg_in_ward9 <- over(knots, ward9_blocks)

covs_knots <- over_knots_bg_in_ward9[, c("total_pop", "med_hh_income")]
covs_knots <- cbind(rep(1, nrow(covs_knots)), covs_knots)
```

```{r}
beta_means <- colMeans(samples_no_burnin[,1:3])
#beta_means <- c(1, 0.1, -0.1)
gp_means <- colMeans(samples_no_burnin[,4:(ncol(samples)-2-n_knots)])

log_intensities <- as.matrix(covs_knots) %*% as.matrix(beta_means) + gp_means
log_intensities_no_gp <- as.matrix(covs_knots) %*% as.matrix(beta_means)
log_intensities_exp <- exp(log_intensities)
```

```{r}
ggplot() +
  geom_density2d_filled(data=obs_pts, aes(x=X, y=Y)) +
  coord_fixed()
```

```{r}
ggplot() +
  geom_point(data=as.data.frame(knots), aes(x = lon, y = lat, color = log_intensities_no_gp), size=5, shape=15) +
  #geom_point(data=obs_pts, aes(x=x, y=y), size=2, shape=1, color="black") +
  scale_color_viridis() +
  coord_fixed()
```

```{r}
ggplot() + 
  geom_point(data=as.data.frame(knots), aes(x = lon, y = lat, color = log_intensities), size=5, shape=15) + 
  scale_color_viridis() + 
  coord_fixed()
```

```{r}
r <- raster(xmn=-10, ymn=-10, xmx=10, ymx=10, res=2)
counts <- as.matrix(rasterize(obs_pts, r, fun='count'))
counts <- counts[nrow(counts):1, ]
counts <- c(t(counts))
area <- 400 / 100
intensities <- counts / area
log_intensities_truth <- log(intensities)

# c(t()) means as vector by row
ggplot() + 
  geom_point(data=knots, aes(x = x, y = y, color = log_intensities_truth), size=15, shape=15) +
  scale_color_viridis() + 
  coord_fixed()
```

```{r}
ggplot(data=NULL, aes(x=log_intensities_no_gp, y=log_intensities_truth)) + 
  geom_point() + 
  geom_smooth(method='lm', formula=y~x, se=F)
```

```{r}
ggplot(data=NULL, aes(x=log_intensities, y=log_intensities_truth)) + 
  geom_point() + 
  geom_smooth(method='lm', formula=y~x, se=F) + 
  coord_fixed()
```

```{r}
ward9_map <- get_map(c(left = -93.28, bottom = 44.93, 
                         right = -93.225, top = 44.965), source = "stamen")
```

```{r}
covs_int <- int_pts
covs_int <- cbind(rep(1, nrow(covs_int)), covs_int)

beta_means <- colMeans(samples_no_burnin[,1:3])
gp_means <- colMeans(samples_no_burnin[,4:(ncol(samples)-2-n_knots)])

log_intensities <- as.matrix(covs_int) %*% as.matrix(beta_means) + integration_pts_vs_knots_cov %*% solve(knots_cov) %*% gp_means
log_intensities_exp <- exp(log_intensities)

ggmap(ward9_map) + 
  geom_point(data=int_pts, aes(x = x, y = y, color = log_intensities), size=2.5) +
  scale_color_viridis() + 
  geom_polygon(data=ward9_blocks, aes(x = long, y = lat, group = group), fill=NA, color="black") + 
  coord_fixed() +
  geom_point(data=obs_pts, aes(x=X, y=Y), alpha=0.1, shape=1) + 
  xlab("Longitude") + 
  ylab("Latitude") + 
  ggtitle("Log intensity surface of all use-of-force incidents, over Ward 9 Minneapolis")
```


